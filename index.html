<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stochastish Gravity</title>
    <meta name="keywords" content="gravity, stochastic, stochastish, computation, computational, physics, exploration">
    <meta name="description" content="Look at gravity differently after reading this article exploring how a temporal gradient could cause gravity without the need for curvature. Though not mathematically rigorous, explore simulations supporting these strange ideas">
    <link rel="stylesheet" href="./index.css" />
    <link rel="stylesheet" href="./menu.css" />
    <link rel="stylesheet" href="./components/modal.css" />
    <script src="./index.js" type="module"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/chartjs-plugin-trendline/dist/chartjs-plugin-trendline.min.js"></script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  </head>
  <body>
    <div id="links">
      <a href="https://ericknock.dev/" target="_blank" id="ericknock"></a>
      <a href="https://eklittlehill.com/" target="_blank" id="eklittlehill"></a>
    </div>
    <div id="menus">
      <div class="holder">
        <div class="menu" id="forceMenu"></div>
        <div class="title">Graphs</div>
        <div class="menu" id="chartMenu"></div>
        <div class="title">Parameters</div>
        <div class="menu" id="paramMenu"></div>
      </div>
    </div>
    <p>
      For the sake of curiosity, I threw out all of what I know about physics. Conservation of energy, gone. Symmetric forces, gone. Deterministic behavior, gone. Fundamentally, the demonstration below has very little to offer for those trying to learn physics because that is not what it’s intended for.
    </p>
    <p>
      I was struck by an idea that I could not get out of my head, and I wanted to prove to myself that it makes sense whether or not it has any practical application besides the programming practice that I got making it. Could I create a logical explanation for something like gravity and time dilation where the first does not cause the latter but the latter causes the first? And could I convince myself that I could invent a computational reason behind why matter causes the latter?
    </p>
    <p>
      Rather than being a rigorous exploration of the math they may be able to formalize these ideas, this article serves as a demonstration of using code to expore such problems even if they might not have any merit beyond that. The exploration itself and how progamming can be used to verify these ideas is the point of this article. My hope is that this can inspre you to explore your own ideas, no matter how silly or absurd they may seem.
    </p>
    <h1>Stochastish Gravity</h1>
    <p>
      The basis of this “Stochastish Gravity” as I have decided to call it (in order to differentiate it from <a href="https://arxiv.org/abs/gr-qc/0307032" target="_blank">stochastic gravity</a>, which is an actual thing) is that all particles feel a force from all other particles, but they are only allowed to experience this force in discrete and somewhat random time steps. Think of these time steps as the ticks of a clock. Each particle can only update its position when its clock ticks.
    </p>
    <p>
      If all of the particles have the same clock, then we have the setup to a regular particle simulation. Because of computation limitations, particle simulations always progress in discrete time steps like this. 60 times per seconds, for example, the particles calculate the forces that they experience, their acceleration, then their velocity, which gives them their new position. Step by step, the simulation continues in this manner. If the time steps are small enough, these simulations give the illusion of continuous motion.
    </p>
    <p>
      This is what we have in the first simulation below. Once per frame, all of the particle’s have their clocks tick. They (currently) feel an attractive force to one another that is inversely proportional to their distance from one another squared, and a repulsive force that is inversely proportional to their distance from one another cubed.
    </p>
    <p>
      Below is the equation for the force that a specific particle <i>i</i> feels from every other particle. If you want to change which values are used in this equation, you can do so in the menu on the right side of the screen. I'd suggest changing them around and seeing how the similation changes. The menu also has other options to change the simulation like the damping factor, which controls how much energy is lost in the system each time a particle moves.
    </p>
    <div class="force-equation"></div>
    <p>
      As the simulation runs, you can see how the average position of the particles (shown in blue) changes. Because there are no external forces acting on these particles, the average position should not move from its original location (shown in green underneath the blue). These particles will just swirl around until they run out of energy (I added a small amount of damping to the system), but the simulation will cut off long before that happens.
    </p>
    <p class="hint">
      Click anywhere within the simulation to start and stop it. While hovering over the simulation, a button will appear in the top left. Clicking this button will reset the simulation. 
    </p>
    <p class="hint">  
      After some time, the standard deviation of the particles will be graphed in the graph below the simulation along with the average distance between the most extreme particles, which I call the span.
    </p>
    <p class="hint">
      While particles are updating they will be shown in yellow. Otherwise they will be shown in red. The green point is the average position of the particles, and the blue point is the current average position of the particles.
    </p>
    <div class="simHolder">
      <div id="global" class="sim">
        <div class="reset"></div>
      </div>
    </div>
    <canvas class="graph" id="globalChart" width="600" height="300"></canvas>
    <p>
      This is fairly boring because every simulation, the results will be the exact same. This is a completely deterministic system because all of the particles tick at the same rate. What happens when the particles do not all tick at the same rate?
    </p>
    <p>
      Before we see that, let’s try to understand what the consequences of this would be. Most importantly, if the particles do not all tick at the same rate, then the forces between the particles will no longer be symmetric. For example, if we have two particles that feel an attractive force, the particle that ticks more frequently will have the ability to experience that force more often, and therefore it will appear as though it experiences a stronger force.
    </p>
    <p>
      Extrapolating this concept, if we have a gradient of ticking speeds, then we would expect particles to move to areas where the ticking speed is slower. This is very similar to one explanation of real-world gravity called the <a href="https://youtu.be/Xc4xYacTu-E?si=61Ahr55EUk497JtE" target="_blank">Law of Cosmic Laziness</a>. Time moves slower in regions of high gravity, so the fact that matter is pulled into these regions by gravity makes matter tend to places where time moves slowest. Same thing happens in this simulation even without any built-in force of gravity.
    </p>
    <p>
      In the simulation, we randomly select a square and tick all of the particles within that square. By changing the way we pick these squares, we can change where the areas of “laziness” are, and we can see whether the particles do tend to move in this direction. If we select the right side of the simulation more often than the left side, then the particles should move left, for example.
    </p>
    <p class="hint">
      Change the options in the selection to change the gradient. If you select “Bias for High Values” for the X direction, squares on the right side of the simulation are more likely to be selected, and squares on the left side will be “lazy” and update less often.
    </p>
    <p class="hint">
      When a square updates, it will flash green.
    </p>
    <div id="selectionOptions">
      <div>
        <label for="x-bias-select">Choose an X-Direction Selection Bias:</label>
        <select id="x-bias-select">
          <option value="noBias">No Bias</option>
          <option value="lowBias">Bias for Low Values</option>
          <option value="highBias">Bias for High Values</option>
          <option value="midBias">Bias for Middle Values</option>
          <option value="outBias">Bias for Outer Values</option>
        </select>
      </div>

      <div>
        <label for="y-bias-select">Choose a Y-Direction Selection Bias:</label>
        <select id="y-bias-select">
          <option value="noBias">No Bias</option>
          <option value="lowBias">Bias for Low Values</option>
          <option value="highBias">Bias for High Values</option>
          <option value="midBias">Bias for Middle Values</option>
          <option value="outBias">Bias for Outer Values</option>
        </select>
      </div>
    </div>
    <div class="simHolder">
      <div id="gradient" class="sim">
        <div class="reset"></div>
      </div>
    </div>
    <canvas class="graph" id="gradientChart" width="600" height="300"></canvas>
    <p>
      If you messed around with the simulation, you would have seen exactly what I described above happening. Setting a bias for lower values makes the particles move to the right. Setting a bias for higher values makes the particles move to the left. Setting a bias for middle values makes particles move either left or right like they’re rolling off of a ridge.
    </p>
    <p>
      Originally this is where I was going to end this article. I wanted to find an intuitive explanation of how time dilation causes gravity. Though this is not at all rigorous, it satisfied the thought I first had about this when I wondered whether time dilation caused gravity instead of the other way around. The “temporal gradient” causes particles to move in a certain direction as though they are being acted on by a force.
    </p>
    <p>
      Imagine that there was a large planet just off of the left side of the simulation, its gravity would cause a gradient of ticking speed similar to what selecting “Bias for High Values” might look like, causing the particles to be “pulled” towards the planet.
    </p>
    <p>
      But there is something lacking from this explanation: what is causing the temporal gradient? Why does space near the planet tick less often than space farther away? I wanted to see whether I could think of answers to these questions using the same framework as we have been using in this article.
    </p>
    <h2>Computational Gravity</h2>
    <p>
      From a very high level it makes sense that areas with fewer particles would take less time to tick. There is less to calculate, fewer forces to compute, fewer particles to move, etc. Would this be enough to get the particles to attract one another?
    </p>
    <p>
      To answer this question, I modified the previous simulation so that each square takes a certain amount of time to tick based on the number of particles inside the square. But this did not give me a worthwhile result because this did not create a temporal gradient at all.
    </p>
    <p>
      The square that took a long time to tick did not attract other particles to it because the squares adjacent to it did not necessarily take a long time to update, and so did not pull particles. If a particle randomly entered the square, it would take a while to get out again, so there was a little bit of a pull from that.
    </p>
    <p>
      After messing with this setup some more (increasing particle counts, increasing and correlating square sizes, etc.), I decided to take a different approach where the size of the update region is not constant.
    </p>
    <p>
      In the simulation below, I pick a random point in the space of the simulation region. From there I pick a random distance. All particles within this distance will be updated at once. Once that is done, I repeat the process by picking a new point and a new distance.
    </p>
    <p>
      This setup allows for a more far-reaching gradient to form because the selection region could be very large, but it still allows particles to be differentiated from one another because the selection region could be very small.
    </p>
    <p>
      Before we add the computational component to this simulation, let’s get familiar with how this new setup works. In this example, whenever a circle is chosen, the particles within are immediately updated. There should be no gravity here because there is no gradient. This is our control.
    </p>
    <div class="simHolder">
      <div id="circle" class="sim">
        <div class="reset"></div>
      </div>
    </div>
    <canvas class="graph" id="circleChart" width="600" height="300"></canvas>
    <p>
      Take note of the trendline for the standard deviation of the particles in this simulation. If this simulation functions the same on your browser as it does on mine, then the trendline should hover around 17. Keep this number in mind.
    </p>
    <p>
      We need this number because if adding different ticking speeds into this simulation causes “gravity” to appear, then we would expect the particles to be pulled towards each other, resulting in a lower standard deviation of their positions.
    </p>
    <p>
      So how can we add different ticking speeds to this simulation? The solution I went with is that, before the particles are allowed to update, they have to wait a time proportional to the number of other updateable particles in the circle. While they are waiting, these particles cannot be selected again.
    </p>
    <p class="hint">
      When I first came up with this idea, I thought about it as multiple threads all selecting circles at the same time. Larger circles would naturally take longer to compute, meaning that particles selected within a dense region would take longer to update. I think that this is a much more natural explanation for this than manually waiting a length of time proportional to the square of the particles being updated, but this is the solution I came up with given the limitations of JavaScript.
      <br></br>
      The biggest part of this setup that irks me is that the length of time is proportional to the square of the number of particles being updated. Computationally, it doesn’t make sense that calculating the positions would not be proportional to the number of particles. I’m not sure what algorithm to compute the new positions could be inefficient enough to cause this effect, but I do think it’s funny to think that our reality (or this constructed reality that we are imagining) runs really inefficiently.
    </p>
    <p>
      If you run the simulation below, hopefully you will see the standard deviation of the particles stay consistently lower than that of the above simulation.
    </p>
    <div class="simHolder">
      <div id="compute" class="sim">
        <div class="reset"></div>
      </div>
    </div>
    <canvas class="graph" id="computeChart" width="600" height="300"></canvas>
    <p>
      After running both of these simulations, it looks like the theory I laid out does work as I expected, and I hope that you see similar results.
    </p>
    <p class="hint">
      Because the implementation is based on a timeout in seconds and not a certain number of updates, the faster your browser is, the more other particles can be updated while a certain circle is waiting for an update. This might make the effect more pronounced on faster machines.
    </p>
    <p>
      For me, the standard deviation hovers around 15, only rarely spiking over 20. Sometimes, though, the selection is quite unlucky, allowing many of the particles to update in quick succession. Because the steady state of this simulation looks to be more compact than the steady state of the previous simulation, when this happens, the particles explode outwards because of the pent-up pressure when they are all crammed together.
    </p>
    <p>
      My hope is that as more particles are added into the simulation, it becomes less likely that one of these events happens.
    </p>
    <p>
      Interestingly, it seems like the gradient simulation with the squares when it is set to have no selection bias has the largest average standard deviation at around 20 on my machine. The globally updating simulation has a standard deviation of around 17 for me, just like the first circle-based simulation.
    </p>
    <h2>Conclusion</h2>
    <p>
      My hope is that this exploration was interesting even if it was not rigorous. If anyone reading this has the technical know-how to formalize this concept in a mathematical way, I would love to know what some consequences of this sort of gravity would be if it were to work this way in an actual setting. I think it would be interesting to use this sort of gravity in the setting of a story and explore what consequences this would have for the characters, and maybe I could even incorporate it into some of my ongoing writing projects, which you can find <a href="https://eklittlehill.com/" target="_blank">here</a>. That page also has a form to contact me if you have any ideas.
    </p>
    <footer>
      <p><a href="https://ericknock.dev/" target="_blank">Eric Knocklein</a> - May 2025</p>
    </footer>
  </body>
</html>
