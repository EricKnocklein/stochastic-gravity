<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stochastic Gravity</title>
    <link rel="stylesheet" href="index.css" />
    <script src="index.js" type="module"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-trendline"></script>
  </head>
  <body>
    <p>
      For the sake of curiosity, I threw out all of what I know about physics. Conservation of energy, gone. Symmetric forces, gone. Deterministic behavior, gone. Fundamentally, the demonstration below has very little to offer for those trying to learn physics because that is not what it’s intended for.
    </p>
    <p>
      I was struck by an idea that I could not get out of my head, and I wanted to prove to myself that it makes sense whether or not it has any practical application besides the programming practice that I got making it. Could I create a logical explanation for something like gravity and time dilation where the first does not cause the latter but the latter causes the first? And could I convince myself that I could invent a computational reason behind why matter causes the latter?    </p>
    <h1>Stochastic Gravity</h1>
    <p>
      The basis of this “Stochastic Gravity” as I decided to call it is that all particles feel a force from all other particles, but they are only allowed to experience this force in discrete time steps. Think of these time steps as the ticks of a clock. Each particle can only update its position when its clock ticks.
    </p>
    <p>
      If all of the particles have the same clock, then we have the setup to a regular particle simulation. Because of computation limitations, particle simulations always progress in discrete time steps like this. 60 times per seconds, for example, the particles calculate the forces that they experience, their acceleration, then their velocity, which gives them their new position. Step by step, the simulation continues in this manner. If the time steps are small enough, these simulations give the illusion of continuous motion.
    </p>
    <p>
      This is what we have in the first simulation below. Once per frame, all of the particle’s have their clocks tick. They feel an attractive force to one another that is inversely proportional to their distance from one another squared, and a repulsive force that is inversely proportional to their distance from one another cubed.
    </p>
    <p>
      As the simulation runs, you can see how the average position of the particles (shown in blue) changes. Because there are no external forces acting on these particles, the average position should not move from its original location (shown in green underneath the blue). These particles will just swirl around until they run out of energy (I added a small amount of damping to the system), but the simulation will cut off long before that happens.
    </p>
    <p class="hint">
      Click anywhere within the simulation to start and stop it. While hovering over the simulation, a button will appear in the top left. Clicking this button will reset the simulation. After some time, the standard deviation of the particles will be graphed in the graph below the simulation along with the average distance between the most extreme particles, which I call the span.
    </p>
    <p class="hint">
      While particles are updating they will be shown in yellow. Otherwise they will be shown in red. The green point is the average position of the particles, and the blue point is the current average position of the particles.
    </p>
    <div class="simHolder">
      <div id="global" class="sim">
        <div class="reset"></div>
      </div>
    </div>
    <canvas id="globalChart" width="600" height="300"></canvas>
    <p>
      This is fairly boring because every simulation, the results will be the exact same. This is a completely deterministic system because all of the particles tick at the same rate. What happens when the particles do not all tick at the same rate?
    </p>
    <p>
      Before we see that, let’s try to understand what the consequences of this would be. Most importantly, if the particles do not all tick at the same rate, then the forces between the particles will no longer be symmetric. For example, if we have two particles that feel an attractive force, the particle that ticks more frequently will have the ability to experience that force more often, and therefore it will appear as though it experiences a stronger force.
    </p>
    <p>
      Extrapolating this concept, if we have a gradient of ticking speeds, then we would expect particles to move to areas where the ticking speed is slower. This is very similar to one explanation of real-world gravity called the Law of Cosmic Laziness. Time moves slower in regions of high gravity, so the fact that matter is pulled into these regions by gravity makes matter tend to places where time moves slowest. Same thing happens in this simulation even without any built-in force of gravity.
    </p>
    <p>
      In the simulation, we randomly select a square and tick all of the particles within that square. By changing the way we pick these squares, we can change where the areas of “laziness” are, and we can see whether the particles do tend to move in this direction. If we select the right side of the simulation more often than the left side, then the particles should move left, for example.
    </p>
    <p class="hint">
      Change the options in the selection to change the gradient. If you select “Bias for High Values” for the X direction, squares on the right side of the simulation are more likely to be selected, and squares on the left side will be “lazy” and update less often.
    </p>
    <p class="hint">
      When a square updates, it will flash green.
    </p>
    <div id="selectionOptions">
      <div>
        <label for="x-bias-select">Choose an X-Direction Selection Bias:</label>
        <select id="x-bias-select">
          <option value="noBias">No Bias</option>
          <option value="lowBias">Bias for Low Values</option>
          <option value="highBias">Bias for High Values</option>
          <option value="midBias">Bias for Middle Values</option>
          <option value="outBias">Bias for Outer Values</option>
        </select>
      </div>

      <div>
        <label for="y-bias-select">Choose a Y-Direction Selection Bias:</label>
        <select id="y-bias-select">
          <option value="noBias">No Bias</option>
          <option value="lowBias">Bias for Low Values</option>
          <option value="highBias">Bias for High Values</option>
          <option value="midBias">Bias for Middle Values</option>
          <option value="outBias">Bias for Outer Values</option>
        </select>
      </div>
    </div>
    <div class="simHolder">
      <div id="gradient" class="sim">
        <div class="reset"></div>
      </div>
    </div>
    <canvas id="gradientChart" width="600" height="300"></canvas>
    <p>
      If you messed around with the simulation, you would have seen exactly what I described above happening. Setting a bias for lower values makes the particles move to the right. Setting a bias for higher values makes the particles move to the left. Setting a bias for middle values makes particles move either left or right like they’re rolling off of a ridge.
    </p>
    <p>
      Originally this is where I was going to end this article. I wanted to find an intuitive explanation of how time dilation causes gravity. Though this is not at all rigorous, it satisfied the thought I first had about this when I wondered whether time dilation caused gravity instead of the other way around. The “temporal gradient” causes particles to move in a certain direction as though they are being acted on by a force.
    </p>
    <p>
      Imagine that there was a large planet just off of the left side of the simulation, its gravity would cause a gradient of ticking speed similar to what selecting “Bias for High Values” might look like, causing the particles to be “pulled” towards the planet.
    </p>
    <p>
      But there is something lacking from this explanation: what is causing the temporal gradient? Why does space near the planet tick less often than space farther away? I wanted to see whether I could think of answers to these questions using the same framework as we have been using in this article.
    </p>
    <h2>Computational Gravity</h2>
    <p>
      From a very high level it makes sense that areas with fewer particles would take less time to tick. There is less to calculate, fewer forces to compute, fewer particles to move, etc. Would this be enough to get the particles to attract one another?
    </p>
    <p>
      To answer this question, I modified the previous simulation so that each square takes a certain amount of time to tick based on the number of particles inside the square. But this did not give me a worthwhile result because this did not create a temporal gradient at all.
    </p>
    <p>
      The square that took a long time to tick did not attract other particles to it because the squares adjacent to it did not necessarily take a long time to update, and so did not pull particles. If a particle randomly entered the square, it would take a while to get out again, so there was a little bit of a pull from that.
    </p>
    <p>
      After messing with this setup some more (increasing particle counts, increasing and correlating square sizes, etc.), I decided to take a different approach where the size of the update region is not constant.
    </p>
    <p>
      In the simulation below, I pick a random point in the space of the simulation region. From there I pick a random distance. All particles within this distance will be updated at once. Once that is done, I repeat the process by picking a new point and a new distance.
    </p>
    <p>
      This setup allows for a more far-reaching gradient to form because the selection region could be very large, but it still allows particles to be differentiated from one another because the selection region could be very small.
    </p>
    <p>
      Before we add the computational component to this simulation, let’s get familiar with how this new setup works. In this example, whenever a circle is chosen, the particles within are immediately updated. There should be no gravity here because there is no gradient. This is our control.
    </p>
    <div class="simHolder">
      <div id="circle" class="sim">
        <div class="reset"></div>
      </div>
    </div>
    <canvas id="circleChart" width="600" height="300"></canvas>
    <p>Compute Sim</p>
    <div class="simHolder">
      <div id="compute" class="sim">
        <div class="reset"></div>
      </div>
    </div>
    <canvas id="computeChart" width="600" height="300"></canvas>
  </body>
</html>
